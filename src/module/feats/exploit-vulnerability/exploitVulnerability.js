import { deleteEVEffect } from "../../socket.js";
import {
  PERSONAL_ANTITHESIS_EFFECT_UUID,
  OFF_GUARD_EFFECT_UUID,
} from "../../utils/index.js";
import {
  createEffectData,
  getActorEVEffect,
  hasFeat,
} from "../../utils/helpers.js";
import { createEVDialog } from "./dialog.js";
import { createEffectOnActor } from "./helpers.js";

async function exploitVuln() {
  //grab the selected token and the targeted token
  const a = canvas.tokens.controlled;
  let ts = Array.from(game.user.targets);

  //make sure we're only targeting one target and have the thaum selected
  if (a.length != 1 || ts.length != 1) {
    return ui.notifications.warn(
      game.i18n.localize(
        "pf2e-thaum-vuln.notifications.warn.exploitVulnerability.targetCount"
      )
    );
  }

  //set the first index in the array as the target and the first controlled token actor as selected actor
  const t = Array.from(ts)[0];
  const sa = a[0].actor;

  //check for exploit vulnerability on the actor
  if (!hasFeat(sa, "exploit-vulnerability")) {
    return ui.notifications.warn(
      game.i18n.localize(
        "pf2e-thaum-vuln.notifications.warn.exploitVulnerability.noExploitVulnerability"
      )
    );
  }

  if (game.settings.get("pf2e-thaum-vuln", "enforceHeldImplement")) {
    if (!Object.values(sa.attributes.implements).some((i) => i.item)) {
      return ui.notifications.warn(
        game.i18n.localize(
          "pf2e-thaum-vuln.notifications.warn.exploitVulnerability.noImplements"
        )
      );
    }
    if (!Object.values(sa.attributes.implements).some((i) => i.item?.isHeld)) {
      return ui.notifications.warn(
        game.i18n.localize(
          "pf2e-thaum-vuln.notifications.warn.exploitVulnerability.noHeldImplement"
        )
      );
    }
  }

  //deletes Exploit Vulnerability effect if it already exists on the actor
  const deleteEffectTargs = preDeleteEffect(canvas.tokens.placeables, sa);
  if (deleteEffectTargs.length > 0) {
    deleteEVEffect(deleteEffectTargs.flat());
  }
  for (let act of canvas.tokens.placeables) {
    let EWEffect = act.actor?.items.find(
      (item) =>
        item.name ===
        game.i18n.localize("pf2e-thaum-vuln.esotericWarden.effect.name")
    );
    if (
      EWEffect &&
      (act.actor === sa ||
        act.actor.getFlag("pf2e-thaum-vuln", "EWSourceActor") === sa.uuid)
    ) {
      EWEffect.delete();
    }
  }

  // From https://gist.github.com/stwlam/01c2506e93c298b01ad83c182b245144 by somebody, Supe, and stwlam
  const skill =
    sa.skills["esoteric-lore"] ??
    sa.skills["esoteric"] ??
    sa.skills["lore-esoteric"];
  if (!skill) {
    return ui.notifications.warn(
      game.i18n.localize(
        "pf2e-thaum-vuln.notifications.warn.exploitVulnerability.noEsotericLoreSkill"
      )
    );
  }
  const dc = game.settings.get("pf2e", "proficiencyVariant")
    ? {
        "-2": 13,
        "-1": 13,
        ...Object.fromEntries(
          Object.entries([
            14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19,
            19, 20, 20, 20, 21, 21, 21, 22, 22,
          ])
        ),
      }[t.actor.level]
    : {
        "-2": 12,
        "-1": 13,
        ...Object.fromEntries(
          Object.entries([
            14, 15, 16, 18, 19, 20, 22, 23, 24, 26, 27, 28, 30, 31, 32, 34, 35,
            36, 38, 39, 40, 42, 44, 46, 48, 50,
          ])
        ),
      }[t.actor.level];
  if (!dc) {
    return ui.notifications.warn(
      game.i18n.localize(
        "pf2e-thaum-vuln.notifications.warn.exploitVulnerability.noMatchingDC"
      )
    );
  }

  const rollOptions = sa.getRollOptions(["skill-check", skill.slug]);

  const outcomes = {
    criticalSuccess: game.i18n.localize(
      "pf2e-thaum-vuln.exploitVulnerability.degreeOfSuccess.criticalSuccess"
    ),
    success: game.i18n.localize(
      "pf2e-thaum-vuln.exploitVulnerability.degreeOfSuccess.success"
    ),
    failure: game.i18n.localize(
      "pf2e-thaum-vuln.exploitVulnerability.degreeOfSuccess.failure"
    ),
    criticalFailure: game.i18n.localize(
      "pf2e-thaum-vuln.exploitVulnerability.degreeOfSuccess.criticalFailure"
    ),
  };

  const notes = Object.entries(outcomes).map(([outcome, text]) => ({
    title: game.i18n.localize("PF2E.Check.Result.Degree.Check." + outcome),
    text,
    outcome: [outcome],
  }));

  if (hasFeat(sa, "esoteric-warden")) {
    notes.push({
      title: game.i18n.localize("pf2e-thaum-vuln.esotericWarden.name"),
      text: game.i18n.localize("pf2e-thaum-vuln.esotericWarden.flavor"),
      outcome: ["success", "criticalSuccess"],
    });
  }

  if (hasFeat(sa, "diverse-lore")) {
    // todo: put npc identify data in the document and then show secret text for it.
    // TODO: Error checking for rolling against PCs
    const dc =
      (game.settings.get("pf2e", "proficiencyVariant")
        ? {
            "-2": 13,
            "-1": 13,
            ...Object.fromEntries(
              Object.entries([
                14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19,
                19, 19, 20, 20, 20, 21, 21, 21, 22, 22,
              ])
            ),
          }[t.actor.level]
        : {
            "-2": 12,
            "-1": 13,
            ...Object.fromEntries(
              Object.entries([
                14, 15, 16, 18, 19, 20, 22, 23, 24, 26, 27, 28, 30, 31, 32, 34,
                35, 36, 38, 39, 40, 42, 44, 46, 48, 50,
              ])
            ),
          }[t.actor.level]) +
      game.settings.get("pf2e-thaum-vuln", "esotericLoreModifier");
    const diverseLoreDC = dc
      ? `<br/><span data-visibility="gm">Recall Knowledge DC ${dc}</span>`
      : "";

    notes.push({
      title: game.i18n.localize("pf2e-thaum-vuln.diverseLore.name"),
      text: `${
        game.i18n.localize("pf2e-thaum-vuln.diverseLore.flavor") + diverseLoreDC
      }`,
      outcome: ["success", "criticalSuccess"],
    });
  }

  const flavor = `${game.i18n.localize(
    "pf2e-thaum-vuln.exploitVulnerability.name"
  )}: ${skill.label}`;
  const checkModifier = new game.pf2e.CheckModifier(flavor, skill);
  const traits = ["esoterica", "manipulate", "thaumaturge"];
  const evRoll = await game.pf2e.Check.roll(
    checkModifier,
    {
      actor: sa,
      target: {
        actor: t.actor,
        token: t.document,
      },
      type: "skill-check",
      options: rollOptions,
      notes,
      dc: { value: dc },
      traits: traits,
      flavor: `
    <strong>${game.i18n.localize(
      "pf2e-thaum-vuln.exploitVulnerability.frequency.label"
    )}</strong> ${game.i18n.localize(
        "pf2e-thaum-vuln.exploitVulnerability.frequency.text"
      )}<br/>
    <strong>${game.i18n.localize(
      "pf2e-thaum-vuln.exploitVulnerability.requirements.label"
    )}</strong> ${game.i18n.localize(
        "pf2e-thaum-vuln.exploitVulnerability.requirements.text"
      )}<br/>
    <hr/>
    <p>${game.i18n.localize("pf2e-thaum-vuln.exploitVulnerability.flavor")}</p>
  `,
    },
    event
  );

  const rollDOS = evRoll?.degreeOfSuccess;
  //Apply effect based on Degrees of success
  switch (rollDOS) {
    case 0:
      //critical failure. Apply off-guard condition for one round.
      await sa.createEmbeddedDocuments("Item", [
        await createEffectData(OFF_GUARD_EFFECT_UUID, {
          actor: sa.uuid,
        }),
      ]);
      break;
    case 1:
      //normal failure. Can only apply personal antithesis.
      await createEffectOnActor(sa, t, PERSONAL_ANTITHESIS_EFFECT_UUID);
      break;
    case 2:
      //normal success. Learns highest weakness. Can apply Mortal Weakness or Personal Antithesis
      await createEVDialog(sa, t, 2);
      break;
    case 3:
      //Critical success. Learns all weaknesses, resistances, and immunities including the amounts and any unusual weaknesses or vulnerabilities
      //Can apply Mortal Weakness or Personal Antithesis.
      await createEVDialog(sa, t, 3);
      break;
    default:
      return;
  }
}

function preDeleteEffect(a, sa = undefined) {
  let effects = new Array();
  for (let token of a) {
    token = token.actor ?? token;
    const effs = getActorEVEffect(token, sa?.uuid);
    for (const effect of effs) {
      if (
        effect.flags["pf2e-thaum-vuln"]?.EffectOrigin === sa?.uuid ||
        effect.flags["pf2e-thaum-vuln"]?.EffectOrigin === token?.uuid
      ) {
        effects.push(effect.uuid);
      }
    }
  }
  return effects;
}

export { exploitVuln, preDeleteEffect };
