import { deleteEVEffect } from "../../socket.js";
import {
  OFF_GUARD_EFFECT_UUID,
  ESOTERIC_WARDEN_EFFECT_UUID,
} from "../../utils/index.js";
import {
  createEffectData,
  getActorEVEffect,
  hasFeat,
} from "../../utils/helpers.js";
import { EVDialog } from "./evDialog.js";
import { createPAOnActor } from "./helpers.js";

async function exploitVuln() {
  //grab the selected token and the targeted token
  const a = canvas.tokens.controlled;
  const ts = Array.from(game.user.targets);

  //make sure we're only targeting one target and have the thaum selected
  if (a.length != 1 || ts.length != 1) {
    return ui.notifications.warn(
      game.i18n.localize(
        "pf2e-thaum-vuln.notifications.warn.exploitVulnerability.targetCount"
      )
    );
  }

  //set the first index in the array as the target and the first controlled token actor as selected actor
  const t = ts[0];
  const sa = a[0].actor;

  //check for exploit vulnerability on the actor
  if (!hasFeat(sa, "exploit-vulnerability")) {
    return ui.notifications.warn(
      game.i18n.localize(
        "pf2e-thaum-vuln.notifications.warn.exploitVulnerability.noExploitVulnerability"
      )
    );
  }

  if (game.settings.get("pf2e-thaum-vuln", "enforceHeldImplement")) {
    if (
      !sa.attributes.implements ||
      !Object.values(sa.attributes.implements).some((i) => i.item)
    ) {
      return ui.notifications.warn(
        game.i18n.localize(
          "pf2e-thaum-vuln.notifications.warn.exploitVulnerability.noImplements"
        )
      );
    }
    if (!Object.values(sa.attributes.implements).some((i) => i.item?.isHeld)) {
      return ui.notifications.warn(
        game.i18n.localize(
          "pf2e-thaum-vuln.notifications.warn.exploitVulnerability.noHeldImplement"
        )
      );
    }
  }

  // From https://gist.github.com/stwlam/01c2506e93c298b01ad83c182b245144 by somebody, Supe, and stwlam
  const skill =
    sa.skills["esoteric-lore"] ??
    sa.skills["esoteric"] ??
    sa.skills["lore-esoteric"];
  if (!skill) {
    return ui.notifications.warn(
      game.i18n.localize(
        "pf2e-thaum-vuln.notifications.warn.exploitVulnerability.noEsotericLoreSkill"
      )
    );
  }

  deleteEffects(sa);

  let notes = [];
  if (hasFeat(sa, "diverse-lore")) {
    // todo: put npc identify data in the document and then show secret text for it.
    // TODO: Error checking for rolling against PCs
    const dc =
      14 +
      Math.floor(t.actor.level / 3) +
      game.settings.get("pf2e-thaum-vuln", "esotericLoreModifier") +
      (game.pf2e.settings.variants.pwol.enabled
        ? 0
        : t.actor.level + (t.actor.level < 0));
    const diverseLoreDC = dc
      ? `<br/><span data-visibility="gm">Recall Knowledge DC ${dc}</span>`
      : "";

    notes.push({
      title: game.i18n.localize("pf2e-thaum-vuln.diverseLore.name"),
      text:
        game.i18n.localize("pf2e-thaum-vuln.diverseLore.flavor") +
        diverseLoreDC,
      outcome: ["success", "criticalSuccess"],
      predicate: ["feat:diverse-lore"],
    });
  }

  const result = await game.pf2e.actions.get("exploit-vulnerability").use({
    actors: [sa],
    target: t.document,
    notes,
    event,
  });

  applyEVResult(sa, t, result[0].roll);
}

// Apply the results of an EV roll to the thaum and target
// @param {ActorPF2e} sa     The thaum.
// @param {TokenPF2e} t      The target of the EV roll.
// @param {CheckRoll} evRoll The result of the EV roll.
async function applyEVResult(sa, t, evRoll) {
  const rollDOS = evRoll?.degreeOfSuccess;
  //Apply effect based on Degrees of success
  switch (rollDOS) {
    case 0:
      //critical failure. Apply off-guard condition for one round.
      await sa.createEmbeddedDocuments("Item", [
        await createEffectData(OFF_GUARD_EFFECT_UUID, {
          actor: sa.uuid,
        }),
      ]);
      break;
    case 1:
      //normal failure. Can only apply personal antithesis.
      await createPAOnActor(sa, t, rollDOS);
      break;
    case 2:
      //normal success. Learns highest weakness. Can apply Mortal Weakness or Personal Antithesis
      new EVDialog(t, sa, 2).render(true);
      break;
    case 3:
      //Critical success. Learns all weaknesses, resistances, and immunities including the amounts and any unusual weaknesses or vulnerabilities
      //Can apply Mortal Weakness or Personal Antithesis.
      new EVDialog(t, sa, 3).render(true);
      break;
    default:
      return;
  }
}

function preDeleteEffect(a, sa = undefined) {
  let effects = new Array();
  for (let token of a) {
    token = token.actor ?? token;
    const effs = getActorEVEffect(token, sa?.uuid);
    for (const effect of effs) {
      if (
        effect.flags["pf2e-thaum-vuln"]?.EffectOrigin === sa?.uuid ||
        effect.flags["pf2e-thaum-vuln"]?.EffectOrigin === token?.uuid
      ) {
        effects.push(effect.uuid);
      }
    }
  }
  return effects;
}

function deleteEffects(actor) {
  //deletes Exploit Vulnerability effect if it already exists on the actor
  const deleteEffectTargs = preDeleteEffect(canvas.tokens.placeables, actor);
  if (deleteEffectTargs.length > 0) {
    deleteEVEffect(deleteEffectTargs.flat());
  }
  // Delete all Esoteric Warden effects from this character
  for (const t of canvas.tokens.placeables) {
    try {
      t.actor.itemTypes.effect
        .filter(
          (e) => e.sourceId === ESOTERIC_WARDEN_EFFECT_UUID && e.origin == actor
        )
        .forEach((e) => e.delete());
    } catch {
      console.error(
        `[PF2E Exploit Vulnerability] - ${t.name} has no actor. This token or its actor is likely corrupted. Delete this token from the scene and re-add it.`,
        t
      );
    }
  }
}

Hooks.once("init", () => {
  const climb = game.pf2e.actions.get("climb");
  const SingleCheckAction = Object.getPrototypeOf(climb).constructor;
  const notes = [
    "criticalSuccess",
    "success",
    "failure",
    "criticalFailure",
  ].map((dos) => ({
    title: game.i18n.localize(`PF2E.Check.Result.Degree.Check.${dos}`),
    text: game.i18n.localize(
      `pf2e-thaum-vuln.exploitVulnerability.degreeOfSuccess.${dos}`
    ),
    outcome: [dos],
  }));

  notes.push({
    title: game.i18n.localize("pf2e-thaum-vuln.esotericWarden.name"),
    text: game.i18n.localize("pf2e-thaum-vuln.esotericWarden.flavor"),
    outcome: ["success", "criticalSuccess"],
    predicate: ["feat:esoteric-warden"],
  });

  const ExploitVulnerability = new SingleCheckAction({
    cost: 1,
    description: "pf2e-thaum-vuln.exploitVulnerability.flavor",
    name: "pf2e-thaum-vuln.exploitVulnerability.name",
    notes,
    rollOptions: ["action:exploit-vulnerability"],
    slug: "exploit-vulnerability",
    difficultyClass: "exploit-vulnerability",
    statistic: "esoteric-lore",
    traits: ["esoterica", "manipulate", "thaumaturge"],
  });

  game.pf2e.actions.set("exploit-vulnerability", ExploitVulnerability);
});

Hooks.on("preCreateChatMessage", async (msg) => {
  if (
    msg.isReroll &&
    msg.isCheckRoll &&
    msg.flags.pf2e.context.dc?.slug === "exploit-vulnerability"
  ) {
    deleteEffects(msg.actor);
    const EWImmuneTargs = msg.actor.getFlag("pf2e-thaum-vuln", "EWImmuneTargs");
    if (EWImmuneTargs?.includes(msg.target.actor.uuid)) {
      await msg.actor.setFlag(
        "pf2e-thaum-vuln",
        "EWImmuneTargs",
        EWImmuneTargs.filter((t) => t != msg.target.actor.uuid)
      );
    }
    applyEVResult(msg.actor, msg.target.token, msg.rolls[0]);
  }
});

export { exploitVuln, preDeleteEffect };
